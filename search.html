<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Dokongg Blog</title>

  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="stylesheet" href="/assets/css/syntax-one-dark.css">
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dokongg Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>
        <div class="trigger">
          <div>
            <div id="search" >
                <span id="searchform" method="post" action="/search/" class="">
    <div class="form-group">
        <input class="search-input" onkeyup="myFunc()" id="keyword" type="text" name="keyword" placeholder="Search..." />
    </div>
    <script src="/assets/js/jquery-3.6.0.min.js"></script>

    <script type="text/javascript">
        function myFunc() {
            var keyword = $("#keyword").val();

            if( keyword.trim() == '' ) {
              return;
            }
            if(event.keyCode == 13) {
                var url = encodeURIComponent(keyword);
                location.href = "/search?query=" + url;
            }
        }
    </script>
</span>

            </div>
          </div>
          
            <a class="page-link" href="/Algorithms/index">Algorithms</a>
          
            <a class="page-link" href="/CS/index">CS</a>
          
            <a class="page-link" href="/Java/index">Java</a>
          
            <a class="page-link" href="/Spring/index">Spring</a>
          
            <a class="page-link" href="/JPA/index">JPA</a>
          
            <a class="page-link" href="/ES/index">ES</a>
          
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
    <div class="post-content search-content">
  <form action="/search" method="get" hidden="hidden">
      <label for="search-box"></label>
      <input type="text" id="search-box" name="query">
  </form>

  <div id="search-result-info"></div>
  <ul class="posts search-posts" id="search-results"></ul>
</div>







<div class="pagination">
</div>
<input type="hidden" id="searchTerm" value="" />
<input type="hidden" id="totalCount" value="5" />
<input type="hidden" id="currentPage" value="1" />
<input type="hidden" id="startPage" value="1" />
<input type="hidden" id="endPage" value="2" />
<input type="hidden" id="totalPageGroup" value="2" />
<input type="hidden" id="currentPageGroup" value="1" />

<script>
    $(document).ready(function() {
      init();

      $('.pagination a').off('click').on('click', function(e) {
        pageEvent($(e.target));
      });

    })

    window.store = {
    
    "spring-02": {
        "title": "[Spring boot] Datasource 여러개 사용하기",
        "category": "",
        "content": "Spring batch에서 두 개의 Datasource를 사용해야 하는 일이 생겼다. 내가 써야하는 Datasource는 Mysql, H2 memory DB 이다.1. dataSource 설정application.yml 에 DataSource 설정을 추가한다.  application.yml12345678910111213datasource:  mysql:    hikari:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: jdbc:mysql://localhost:3306/testdb      username:      password:h2:  hikari:    driver-class-name: org.h2.Driver    jdbc-url: jdbc:h2:mem:h2db    username: sa    password:2. DataSource 선언사용하려는 DataSource를 선언해 준다. application.yml에 있는 spring.datasource.{??}.hikari 아래의 설정으로 dataSource를 가져온다.  기본 dataSource는 mysql DB이다.  다른 dataSource는 h2 memory DB이다.  DatasourceConfiguration.java1234567891011121314151617@Configuration@EnableConfigurationPropertiespublic class DatasourceConfiguration {\t@Bean(name=\"dataSource\")\t@Primary\t@ConfigurationProperties(prefix = \"spring.datasource.mysql.hikari\")\tpublic DataSource createMysqlDataSource() {\t\treturn DataSourceBuilder.create().type(HikariDataSource.class).build();\t}\t@Bean(name=\"h2DataSource\")\t@ConfigurationProperties(prefix = \"spring.datasource.h2.hikari\")\tpublic DataSource createH2DataSource() {\t\treturn DataSourceBuilder.create().type(HikariDataSource.class).build();\t}}3. DataSource 사용Primary Bean이 아닌 DataSource를 사용하려면 @Qualifier(name=”“)으로 가져온다.@Qualifier 설정을 안 하면 변수명이 Bean 이름과 같아도 자동으로 Primary Bean을 가져오게 된다.나중에 TransactionManager나 SqlSessionFactory 등 더 필요한 DB 설정이 있다면 Vendor 별로 나누어서 Configuration 설정을 주는 것도 좋을 것 같다.",
        "url": "/Spring-02"
    }
    ,
    
    "spring-01": {
        "title": "[Spring boot] method parameter에 bean의 자동 주입",
        "category": "",
        "content": "요새 Spring boot에서 Spring batch로 Batch를 개발 중이다.@Configuration으로 Job을 생성하고 있는데, 이 때 신기한 현상을 발견했다.내가 만든 Job 생성 method에서는 수행할 Step을 parameter로 넘겨주고 있었는데, 해당 parameter명으로 Bean이 자동으로 주입되고 있었다!어떻게 된 것인지 내가 이해한 정도로만 정리했다.(지금 내가 테스트 하고 있는 완전 간단한 Job의 설정이다.)12345678910111213141516171819202122232425@Slf4j@Configurationpublic class Job1Configuration {    @Autowired    private JobBuilderFactory jobBuilderFactory;    @Autowired    private StepBuilderFactory stepBuilderFactory;    @Bean(name = \"JOB1\")    public Job createJob(Step step1) {        return jobBuilderFactory.get(\"JOB1\")                .start(step1)                .build();    }    @Bean(name = \"STEP1\")    public Step createStep1() {        return stepBuilderFactory.get(\"STEP1\")                .tasklet((contribution, chunckContext) -&gt; {                    log.info(\"Step1 is started\");                    return RepeatStatus.FINISHED;                })                .build();    }}(1) ConstructorResolver.java에서 이름이 JOB1인 Bean을 생성하려고 한다.  ConstructorResolver.java123456789101112131415161718192021222324252627282930...public BeanWrapper instantiateUsingFactoryMethod(    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {  BeanWrapperImpl bw = new BeanWrapperImpl();  this.beanFactory.initBeanWrapper(bw);  Object factoryBean;  Class&lt;?&gt; factoryClass;  boolean isStatic;  String factoryBeanName = mbd.getFactoryBeanName();  if (factoryBeanName != null) {    if (factoryBeanName.equals(beanName)) {      throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,          \"factory-bean reference points back to the same bean definition\");    }    factoryBean = this.beanFactory.getBean(factoryBeanName);    if (mbd.isSingleton() &amp;&amp; this.beanFactory.containsSingleton(beanName)) {      throw new ImplicitlyAppearedSingletonException();    }    this.beanFactory.registerDependentBean(factoryBeanName, beanName);    factoryClass = factoryBean.getClass();    isStatic = false;  }...(2) Bean의 후보가 될 수 있는 candidates(여기서는 JOB1 Bean 한 개)에 대해서 for문을 돌게 된다. (3) JOB1의 parameter는 한 개 이기 때문에 parameterCount는 1이 된다(minNrOfArgs 는 0).  ConstructorResolver.java123456789101112131415161718192021222324252627...public BeanWrapper instantiateUsingFactoryMethod(    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {...Deque&lt;UnsatisfiedDependencyException&gt; causes = null;for (Method candidate : candidates) {  int parameterCount = candidate.getParameterCount();  if (parameterCount &gt;= minNrOfArgs) {    ArgumentsHolder argsHolder;    Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();    if (explicitArgs != null) {      // Explicit arguments given -&gt; arguments length must match exactly.      if (paramTypes.length != explicitArgs.length) {        continue;      }      argsHolder = new ArgumentsHolder(explicitArgs);    }...(4) createArgumetArray 메소드로 agrumentArray를 생성하게 된다.이 때, resolveAutowiredArgument 메소드로 autowiredArgument 객체를 생성하게 된다(실제로 얘를 나중에 parameter로 가져오는 듯).  ConstructorResolver.java12345678910111213141516171819202122232425262728293031323334353637...public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,    @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable Object[] explicitArgs) {...ArgumentsHolder argsHolder;Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();if (resolvedValues != null) {  try {    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);    if (paramNames == null) {      ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();      if (pnd != null) {        paramNames = pnd.getParameterNames(candidate);      }    }    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,        getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);  }  catch (UnsatisfiedDependencyException ex) {    if (logger.isTraceEnabled()) {      logger.trace(\"Ignoring constructor [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);    }    // Swallow and try next constructor.    if (causes == null) {      causes = new ArrayDeque&lt;&gt;(1);    }    causes.add(ex);    continue;  }}...123456789101112131415161718192021222324252627282930...private ArgumentsHolder createArgumentArray(    String beanName, RootBeanDefinition mbd, @Nullable ConstructorArgumentValues resolvedValues,    BeanWrapper bw, Class&lt;?&gt;[] paramTypes, @Nullable String[] paramNames, Executable executable,    boolean autowiring, boolean fallback) throws UnsatisfiedDependencyException {  TypeConverter customConverter = this.beanFactory.getCustomTypeConverter();  TypeConverter converter = (customConverter != null ? customConverter : bw);  ArgumentsHolder args = new ArgumentsHolder(paramTypes.length);  Set&lt;ConstructorArgumentValues.ValueHolder&gt; usedValueHolders = new HashSet&lt;&gt;(paramTypes.length);  Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(4);...    try {      Object autowiredArgument = resolveAutowiredArgument(methodParam, beanName, autowiredBeanNames, converter, fallback);    args.rawArguments[paramIndex] = autowiredArgument;    args.arguments[paramIndex] = autowiredArgument;    args.preparedArguments[paramIndex] = autowiredArgumentMarker;    args.resolveNecessary = true;    }    catch (BeansException ex) {        throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex);    }  ...(5) resolveAutowiredArgument 메소드에서는 beanFactory의 resolveDependency를 통해 param에 해당하는 Bean을 찾아오게 된다.  ConstructorResolver.java12345678910111213141516171819202122232425...@Nullableprotected Object resolveAutowiredArgument(MethodParameter param, String beanName,    @Nullable Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter, boolean fallback) {  Class&lt;?&gt; paramType = param.getParameterType();  if (InjectionPoint.class.isAssignableFrom(paramType)) {    InjectionPoint injectionPoint = currentInjectionPoint.get();    if (injectionPoint == null) {      throw new IllegalStateException(\"No current InjectionPoint available for \" + param);    }    return injectionPoint;  }  try {    return this.beanFactory.resolveDependency(        new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);  }  catch (NoUniqueBeanDefinitionException ex) {    throw ex;  }...어떻게 자동으로 주입되는지가 궁금해서 직접 찾아봤는데, 너무 깊게 찾아본 것 같기도..Parameter의 type과 name만 있으면 Bean Factory에서 찾아주는 것 같다.      검색하면서 찾아본 글의 댓글에 있던 내용 참고하기        다른 얘기로 스프링 4.3 이후부터는 생성자에 @Autowired를 쓰지 않아도 생성자의 파라미터 타입의 빈이 있으면 자동으로 주입해줍니다.(출처: https://jeong-pro.tistory.com/167 [기본기를 쌓는 정아마추어 코딩블로그] )  ",
        "url": "/Spring-01"
    }
    ,
    
    "java-010": {
        "title": "[Java] 중괄호로 변수범위 정하기",
        "category": "",
        "content": "코드 중간에 뜬금포로 중괄호를 둔 코드를 누가 물어봤다.코드의 가독성을 좋게 하는 것도 있지만, 변수 범위를 정하기 위해 사용한다고 한다.1234{  int a = 0;}System.out.println(a); // ERROR!Java는 GC가 있는데 필요한 경우가 있을까? 생각해봐야겠다.  참고(https://stackoverflow.com/questions/5466974/multiple-open-and-close-curly-brackets-inside-method-java)",
        "url": "/Java-010"
    }
    ,
    
    "java-01": {
        "title": "[Java] 중괄호로 변수범위 정하기",
        "category": "",
        "content": "코드 중간에 뜬금포로 중괄호를 둔 코드를 누가 물어봤다.코드의 가독성을 좋게 하는 것도 있지만, 변수 범위를 정하기 위해 사용한다고 한다.1234{  int a = 0;}System.out.println(a); // ERROR!Java는 GC가 있는데 필요한 경우가 있을까? 생각해봐야겠다.  참고(https://stackoverflow.com/questions/5466974/multiple-open-and-close-curly-brackets-inside-method-java)",
        "url": "/Java-01"
    }
    ,
    
    "algorithms-01": {
        "title": "[Programmers] 기능개발",
        "category": "",
        "content": "■ 문제https://programmers.co.kr/learn/courses/30/lessons/42586■ 생각하기■ 내 풀이123// code block TEST■ NOTE",
        "url": "/Algorithms-01"
    }
    
    
    };
</script>
<script src="/assets/js/lunr.js"></script>
<script src="/assets/js/search.js"></script>

</article>

      </div>
    </main>
    <script src="/assets/js/jquery-3.6.0.min.js" />
  </body>

</html>
