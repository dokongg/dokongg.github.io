<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Dokongg Blog</title>

  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="stylesheet" href="/assets/css/syntax-one-dark.css">
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dokongg Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>
        <div class="trigger">
          <div>
            <div id="search" >
                <span id="searchform" method="post" action="/search/" class="">
    <div class="form-group">
        <input class="search-input" onkeyup="myFunc()" id="keyword" type="text" name="keyword" placeholder="Search..." />
    </div>
    <script src="/assets/js/jquery-3.6.0.min.js"></script>

    <script type="text/javascript">
        function myFunc() {
            var keyword = $("#keyword").val();

            if( keyword.trim() == '' ) {
              return;
            }
            if(event.keyCode == 13) {
                var url = encodeURIComponent(keyword);
                location.href = "/search?query=" + url;
            }
        }
    </script>
</span>

            </div>
          </div>
          
            <a class="page-link" href="/Algorithms/index">Algorithms</a>
          
            <a class="page-link" href="/CS/index">CS</a>
          
            <a class="page-link" href="/Java/index">Java</a>
          
            <a class="page-link" href="/Spring/index">Spring</a>
          
            <a class="page-link" href="/JPA/index">JPA</a>
          
            <a class="page-link" href="/ES/index">ES</a>
          
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
    <div class="post-content search-content">
  <form action="/search" method="get" hidden="hidden">
      <label for="search-box"></label>
      <input type="text" id="search-box" name="query">
  </form>

  <div id="search-result-info"></div>
  <ul class="posts search-posts" id="search-results"></ul>
</div>







<div class="pagination">
</div>
<input type="hidden" id="searchTerm" value="" />
<input type="hidden" id="totalCount" value="5" />
<input type="hidden" id="currentPage" value="1" />
<input type="hidden" id="startPage" value="1" />
<input type="hidden" id="endPage" value="2" />
<input type="hidden" id="totalPageGroup" value="2" />
<input type="hidden" id="currentPageGroup" value="1" />

<script>
    $(document).ready(function() {
      init();

      $('.pagination a').off('click').on('click', function(e) {
        pageEvent($(e.target));
      });

    })

    window.store = {
    
    "cs-os": {
        "title": "Part 1-4. 운영체제",
        "category": "",
        "content": "[목차]  프로세스와 스레드의 차이 1.1. 프로세스(Process) 1.2. 프로세스 제어 블록(PCB, Process Control Block) 1.3. 스레드(Thread)1. 프로세스와 스레드의 차이1.1. 프로세스(Process)(1) 프로세스란?  실행 중인 프로그램  디스크로부터 메모리에 적재되어 CPU의 할당을 받을수 있는 것  운영체제로부터 주소 공간, 파일, 메모리 등을 할당받는다.(2) 프로세스의 구성  함수의 매개변수, 복귀주소와 로컬변수와 같은 임시자료를 갖는 프로세스 스택과 전역변수들을 수록하는 데이터 섹션을 포함1.2. 프로세스 제어블록(PCB, Process Control Block)(1) PCB란?  특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조(2) PCB의 역할  운영체제는 프로세스를 관리하기 위해 프로세스를 생성하는 것과 동시에 고유한 PCB를 생성한다.  프로세스는 CPU의 할당을 받아 작업을 처리하다가 프로세스를 전환하는 일이 발생하면, 진행하던 작업을 저장한 다음 CPU를 반환해야 한다. 이 때, 작업하던 진행사항을 모두 PCB에 저장하게 된다. 그리고 다시 CPU를 할당받으면, PCB에 저장되어 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 시작한다.(3) PCB에 저장되는 정보  프로세스 식별자(Process ID, PID): 프로세스 식별번호  프로세스 상태: new/ready/running/waiting/ternimated 등의 상태를 저장  프로그램 카운터: 프로세스가 다음에 실행할 명령어의 주소  CPU 레지스터  CPU 스케줄링 정보: 프로세스 우선순위, 스케줄 큐에 대한 포인터 등  메모리 관리정보: 페이지 테이블 또는 세그먼트 테이블과 같은 정보를 포함  입출력 상태정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록      어카운팅 정보    참고: https://github.com/JaeYeopHan/Interview_Question_for_Beginner",
        "url": "/CS-OS"
    }
    ,
    
    "algorithms-01": {
        "title": "[Programmers] 기능개발",
        "category": "",
        "content": "■ 문제https://programmers.co.kr/learn/courses/30/lessons/42586■ 내 풀이123456789101112131415161718192021222324252627282930313233343536373839404142public Integer[] solution(int[] progresses, int[] speeds) {  int i = 0;  int length = progresses.length;  boolean[] out = new boolean[length];  for (int j = 0; j &lt; length; j++) {    progresses[j] = 100 - progresses[j];  }  List&lt;Integer&gt; result = new ArrayList&lt;&gt;();  while (i &lt; length - 1) {    int day = (int) Math.ceil(progresses[i] / (speeds[i] * 1.0));    progresses[i] -= speeds[i] * day;    out[i] = true;    for (int j = i + 1; j &lt; length; j++) {      progresses[j] -= speeds[j] * day;      if (progresses[j] &lt;= 0) {        out[j] = true;      }    }    int count = 1;    for (int j = i + 1; j &lt; length; j++) {      i = j;      if (!out[j]) {        break;      } else {        count++;      }    }    result.add(count);  }  if (!out[length - 1]) {    result.add(1);  }  return result.toArray(new Integer[result.size()]);}■ NOTE ① 첫 번째 정답 코드 풀이 참조1int[] dayOfend = new int[100];으로 선언하고, for문 내에1dayOfend[day]++;한 다음 리턴은1return Arrays.stream(dayOfend).filter(i -&gt; i!=0).toArray();② 처음에는 brute-force로 생각하고, 두 번째로 계산하면서 할 수 있는 지 고려해보기.",
        "url": "/Algorithms-01"
    }
    ,
    
    "spring-02": {
        "title": "[Spring boot] Datasource 여러개 사용하기",
        "category": "",
        "content": "Spring batch에서 두 개의 Datasource를 사용해야 하는 일이 생겼다. 내가 써야하는 Datasource는 Mysql, H2 memory DB 이다.1. dataSource 설정application.yml 에 DataSource 설정을 추가한다.  application.yml12345678910111213datasource:  mysql:    hikari:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: jdbc:mysql://localhost:3306/testdb      username:      password:h2:  hikari:    driver-class-name: org.h2.Driver    jdbc-url: jdbc:h2:mem:h2db    username: sa    password:2. DataSource 선언사용하려는 DataSource를 선언해 준다. application.yml에 있는 spring.datasource.{??}.hikari 아래의 설정으로 dataSource를 가져온다.  기본 dataSource는 mysql DB이다.  다른 dataSource는 h2 memory DB이다.  DatasourceConfiguration.java1234567891011121314151617@Configuration@EnableConfigurationPropertiespublic class DatasourceConfiguration {\t@Bean(name=\"dataSource\")\t@Primary\t@ConfigurationProperties(prefix = \"spring.datasource.mysql.hikari\")\tpublic DataSource createMysqlDataSource() {\t\treturn DataSourceBuilder.create().type(HikariDataSource.class).build();\t}\t@Bean(name=\"h2DataSource\")\t@ConfigurationProperties(prefix = \"spring.datasource.h2.hikari\")\tpublic DataSource createH2DataSource() {\t\treturn DataSourceBuilder.create().type(HikariDataSource.class).build();\t}}3. DataSource 사용Primary Bean이 아닌 DataSource를 사용하려면 @Qualifier(name=”“)으로 가져온다.@Qualifier 설정을 안 하면 변수명이 Bean 이름과 같아도 자동으로 Primary Bean을 가져오게 된다.나중에 TransactionManager나 SqlSessionFactory 등 더 필요한 DB 설정이 있다면 Vendor 별로 나누어서 Configuration 설정을 주는 것도 좋을 것 같다.",
        "url": "/Spring-02"
    }
    ,
    
    "spring-01": {
        "title": "[Spring boot] method parameter에 bean의 자동 주입",
        "category": "",
        "content": "요새 Spring boot에서 Spring batch로 Batch를 개발 중이다. Job을 생성하고 있는데, 이 때 신기한 현상을 발견했다.내가 만든 Job 생성 method에서는 수행할 Step을 parameter로 넘겨주고 있었는데, 해당 parameter명으로 Bean이 자동으로 주입되고 있었다!어떻게 된 것인지 내가 이해한 정도로만 정리했다.(지금 내가 테스트 하고 있는 완전 간단한 Job의 설정이다.)12345678910111213141516171819202122232425@Slf4j@Configurationpublic class Job1Configuration {    @Autowired    private JobBuilderFactory jobBuilderFactory;    @Autowired    private StepBuilderFactory stepBuilderFactory;    @Bean(name = \"JOB1\")    public Job createJob(Step step1) {        return jobBuilderFactory.get(\"JOB1\")                .start(step1)                .build();    }    @Bean(name = \"STEP1\")    public Step createStep1() {        return stepBuilderFactory.get(\"STEP1\")                .tasklet((contribution, chunckContext) -&gt; {                    log.info(\"Step1 is started\");                    return RepeatStatus.FINISHED;                })                .build();    }}(1) ConstructorResolver.java에서 이름이 JOB1인 Bean을 생성하려고 한다.  ConstructorResolver.java123456789101112131415161718192021222324252627282930...public BeanWrapper instantiateUsingFactoryMethod(    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {  BeanWrapperImpl bw = new BeanWrapperImpl();  this.beanFactory.initBeanWrapper(bw);  Object factoryBean;  Class&lt;?&gt; factoryClass;  boolean isStatic;  String factoryBeanName = mbd.getFactoryBeanName();  if (factoryBeanName != null) {    if (factoryBeanName.equals(beanName)) {      throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,          \"factory-bean reference points back to the same bean definition\");    }    factoryBean = this.beanFactory.getBean(factoryBeanName);    if (mbd.isSingleton() &amp;&amp; this.beanFactory.containsSingleton(beanName)) {      throw new ImplicitlyAppearedSingletonException();    }    this.beanFactory.registerDependentBean(factoryBeanName, beanName);    factoryClass = factoryBean.getClass();    isStatic = false;  }...(2) Bean의 후보가 될 수 있는 candidates(여기서는 JOB1 Bean 한 개)에 대해서 for문을 돌게 된다. (3) JOB1의 parameter는 한 개 이기 때문에 parameterCount는 1이 된다(minNrOfArgs 는 0).  ConstructorResolver.java123456789101112131415161718192021222324252627...public BeanWrapper instantiateUsingFactoryMethod(    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {...Deque&lt;UnsatisfiedDependencyException&gt; causes = null;for (Method candidate : candidates) {  int parameterCount = candidate.getParameterCount();  if (parameterCount &gt;= minNrOfArgs) {    ArgumentsHolder argsHolder;    Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();    if (explicitArgs != null) {      // Explicit arguments given -&gt; arguments length must match exactly.      if (paramTypes.length != explicitArgs.length) {        continue;      }      argsHolder = new ArgumentsHolder(explicitArgs);    }...(4) createArgumetArray 메소드로 agrumentArray를 생성하게 된다.이 때, resolveAutowiredArgument 메소드로 autowiredArgument 객체를 생성하게 된다(실제로 얘를 나중에 parameter로 가져오는 듯).  ConstructorResolver.java12345678910111213141516171819202122232425262728293031323334353637...public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,    @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable Object[] explicitArgs) {...ArgumentsHolder argsHolder;Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();if (resolvedValues != null) {  try {    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);    if (paramNames == null) {      ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();      if (pnd != null) {        paramNames = pnd.getParameterNames(candidate);      }    }    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,        getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);  }  catch (UnsatisfiedDependencyException ex) {    if (logger.isTraceEnabled()) {      logger.trace(\"Ignoring constructor [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);    }    // Swallow and try next constructor.    if (causes == null) {      causes = new ArrayDeque&lt;&gt;(1);    }    causes.add(ex);    continue;  }}...123456789101112131415161718192021222324252627282930...private ArgumentsHolder createArgumentArray(    String beanName, RootBeanDefinition mbd, @Nullable ConstructorArgumentValues resolvedValues,    BeanWrapper bw, Class&lt;?&gt;[] paramTypes, @Nullable String[] paramNames, Executable executable,    boolean autowiring, boolean fallback) throws UnsatisfiedDependencyException {  TypeConverter customConverter = this.beanFactory.getCustomTypeConverter();  TypeConverter converter = (customConverter != null ? customConverter : bw);  ArgumentsHolder args = new ArgumentsHolder(paramTypes.length);  Set&lt;ConstructorArgumentValues.ValueHolder&gt; usedValueHolders = new HashSet&lt;&gt;(paramTypes.length);  Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(4);...    try {      Object autowiredArgument = resolveAutowiredArgument(methodParam, beanName, autowiredBeanNames, converter, fallback);    args.rawArguments[paramIndex] = autowiredArgument;    args.arguments[paramIndex] = autowiredArgument;    args.preparedArguments[paramIndex] = autowiredArgumentMarker;    args.resolveNecessary = true;    }    catch (BeansException ex) {        throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex);    }  ...(5) resolveAutowiredArgument 메소드에서는 beanFactory의 resolveDependency를 통해 param에 해당하는 Bean을 찾아오게 된다.  ConstructorResolver.java12345678910111213141516171819202122232425...@Nullableprotected Object resolveAutowiredArgument(MethodParameter param, String beanName,    @Nullable Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter, boolean fallback) {  Class&lt;?&gt; paramType = param.getParameterType();  if (InjectionPoint.class.isAssignableFrom(paramType)) {    InjectionPoint injectionPoint = currentInjectionPoint.get();    if (injectionPoint == null) {      throw new IllegalStateException(\"No current InjectionPoint available for \" + param);    }    return injectionPoint;  }  try {    return this.beanFactory.resolveDependency(        new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);  }  catch (NoUniqueBeanDefinitionException ex) {    throw ex;  }...어떻게 자동으로 주입되는지가 궁금해서 직접 찾아봤는데, 너무 깊게 찾아본 것 같기도..Parameter의 type과 name만 있으면 Bean Factory에서 찾아주는 것 같다.      검색하면서 찾아본 글의 댓글에 있던 내용 참고하기        다른 얘기로 스프링 4.3 이후부터는 생성자에 @Autowired를 쓰지 않아도 생성자의 파라미터 타입의 빈이 있으면 자동으로 주입해줍니다.(출처: https://jeong-pro.tistory.com/167 [기본기를 쌓는 정아마추어 코딩블로그] )  ",
        "url": "/Spring-01"
    }
    ,
    
    "java-01": {
        "title": "[Java] 중괄호로 변수범위 정하기",
        "category": "",
        "content": "코드 중간에 뜬금포로 중괄호를 둔 코드를 누가 물어봤다.코드의 가독성을 좋게 하는 것도 있지만, 변수 범위를 정하기 위해 사용한다고 한다.1234{  int a = 0;}System.out.println(a); // ERROR!Java는 GC가 있는데 필요한 경우가 있을까? 생각해봐야겠다.  참고(https://stackoverflow.com/questions/5466974/multiple-open-and-close-curly-brackets-inside-method-java)",
        "url": "/Java-01"
    }
    
    
    };
</script>
<script src="/assets/js/lunr.js"></script>
<script src="/assets/js/search.js"></script>

</article>

      </div>
    </main>
    <script src="/assets/js/jquery-3.6.0.min.js" />
  </body>

</html>
