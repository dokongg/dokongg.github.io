<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Dokongg Blog</title>

  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="stylesheet" href="/assets/css/syntax-one-dark.css">
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dokongg Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>
        <div class="trigger">
          <div>
            <div id="search" >
                <span id="searchform" method="post" action="/search/" class="">
    <div class="form-group">
        <input class="search-input" onkeyup="myFunc()" id="keyword" type="text" name="keyword" placeholder="Search..." />
    </div>
    <script src="/assets/js/jquery-3.6.0.min.js"></script>

    <script type="text/javascript">
        function myFunc() {
            var keyword = $("#keyword").val();

            if( keyword.trim() == '' ) {
              return;
            }
            if(event.keyCode == 13) {
                var url = encodeURIComponent(keyword);
                location.href = "/search?query=" + url;
            }
        }
    </script>
</span>

            </div>
          </div>
          
            <a class="page-link" href="/Algorithms/index">Algorithms</a>
          
            <a class="page-link" href="/CS/index">CS</a>
          
            <a class="page-link" href="/Java/index">Java</a>
          
            <a class="page-link" href="/Spring/index">Spring</a>
          
            <a class="page-link" href="/JPA/index">JPA</a>
          
            <a class="page-link" href="/ES/index">ES</a>
          
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h3 class="post-title p-name" itemprop="name headline">Part 1-4. 운영체제</h3>
    <p class="post-meta post-right"><time class="dt-published" datetime="2021-05-06T00:00:00+00:00" itemprop="datePublished">
        2021-05-06
      </time></p>
  </header>

  <div class="post-content e-content post-content-body" itemprop="articleBody">
    <p>[목차]</p>
<ol>
  <li>프로세스와 스레드의 차이 <br />
1.1. 프로세스(Process) <br />
1.2. 프로세스 제어 블록(PCB, Process Control Block) <br />
1.3. 스레드(Thread)</li>
  <li>멀티 스레드 <br />
2.1. 멀티 스레드의 장점 <br />
2.2. 멀티 스레드의 문제점 <br />
2.3. 멀티 스레드와 멀티 프로세스</li>
  <li>스케줄러 <br />
3.1. Queue의 종류 <br />
3.2. 장기 스테줄러 <br />
3.3. 단기 스케줄러 <br />
3.4. 중기 스케줄러</li>
</ol>

<hr />

<h4 id="1-프로세스와-스레드의-차이"><strong>1. 프로세스와 스레드의 차이</strong></h4>
<h5 id="11-프로세스process"><strong>1.1. 프로세스(Process)</strong></h5>
<p>(1) 프로세스란?</p>
<ul>
  <li>실행 중인 프로그램</li>
  <li>디스크로부터 메모리에 적재되어 CPU의 할당을 받을수 있는 것</li>
  <li>운영체제로부터 주소 공간, 파일, 메모리 등을 할당받는다.</li>
</ul>

<p>(2) 프로세스의 구성</p>
<ul>
  <li>함수의 매개변수, 복귀주소와 로컬변수와 같은 임시자료를 갖는 프로세스 스택과 전역변수들을 수록하는 데이터 섹션을 포함</li>
  <li>프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함</li>
</ul>

<h5 id="12-프로세스-제어블록pcb-process-control-block"><strong>1.2. 프로세스 제어블록(PCB, Process Control Block)</strong></h5>
<p>(1) PCB란?</p>
<ul>
  <li>특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조</li>
</ul>

<p>(2) PCB의 역할</p>
<ul>
  <li>운영체제는 프로세스를 관리하기 위해 프로세스를 생성하는 것과 동시에 고유한 PCB를 생성한다.</li>
  <li>프로세스는 CPU의 할당을 받아 작업을 처리하다가 프로세스를 전환하는 일이 발생하면, 진행하던 작업을 저장한 다음 CPU를 반환해야 한다. 이 때, 작업하던 진행사항을 모두 PCB에 저장하게 된다. 그리고 다시 CPU를 할당받으면, PCB에 저장되어 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 시작한다.</li>
</ul>

<p>(3) PCB에 저장되는 정보</p>
<ul>
  <li>프로세스 식별자(Process ID, PID): 프로세스 식별번호</li>
  <li>프로세스 상태: new/ready/running/waiting/ternimated 등의 상태를 저장</li>
  <li>프로그램 카운터: 프로세스가 다음에 실행할 명령어의 주소</li>
  <li>CPU 레지스터</li>
  <li>CPU 스케줄링 정보: 프로세스 우선순위, 스케줄 큐에 대한 포인터 등</li>
  <li>메모리 관리정보: 페이지 테이블 또는 세그먼트 테이블과 같은 정보를 포함</li>
  <li>입출력 상태정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록</li>
  <li>어카운팅 정보</li>
</ul>

<h5 id="13-스레드thread"><strong>1.3. 스레드(Thread)</strong></h5>
<p>(1) 스레드란?</p>
<ul>
  <li>프로세스의 실행 단위</li>
  <li>한 프로세스 내에서 동작하는 여러 실행 흐름</li>
  <li>프로세스 내 주소 공간이나 자원을 공유할 수 있다.</li>
  <li>스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성
    <ul>
      <li>각자의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택, PC 레지스터 값을 갖고 있다.</li>
    </ul>
  </li>
</ul>

<p>(2) 스레드의 역할</p>
<ul>
  <li>같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다.</li>
</ul>

<p>(3) 멀티 스레딩</p>
<ul>
  <li>하나의 프로세스를 여러 개의 실행 단위로 구분하여, 자원을 공유하고 자원의 생성과 관리의 중복을 최소화하여 수행 능력을 향상시키는 것</li>
</ul>

<p>(4) 스레드마다 스택을 독립적으로 할당하는 이유</p>
<ul>
  <li>스택이란?
    <ul>
      <li>함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간</li>
      <li>스택 메모리 공간이 독립적이다 = 독립적인 함수 호출이 가능하며, 독립적인 실행 흐름이 추가된다.</li>
    </ul>
  </li>
  <li>스레드의 정의에 따라 독립적인 실행흐름을 추가하기 위한 최소조건이기 때문</li>
</ul>

<p>(5) 스레드마다 PC Register를 독립적으로 할당하는 이유</p>
<ul>
  <li>PC Register의 값은 스레드가 명령어를 어디까지 수행했는 지를 나타냄</li>
  <li>스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당하기 때문에, 명령어를 연속적으로 수행하지 못한다. 따라서, 명령어를 어느 부분까지 수행했는지 기억할 필요가 있기 때문</li>
</ul>

<h4 id="2-멀티-스레드"><strong>2. 멀티 스레드</strong></h4>
<h5 id="21-멀티-스레딩의-장점"><strong>2.1. 멀티 스레딩의 장점</strong></h5>
<ul>
  <li>프로세스를 이용해 동시에 처리하던 일을 스레드로 구현하면, 메모리 공간과 시스템 자원의 소모가 줄어들게 된다.</li>
  <li>스레드 간 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용하여 데이터를 주고 받을 수 있다(스레드 간 통신 방법은 프로세스 간 통신 방법보다 훨씬 간단하다).</li>
  <li>스레드의 Context switch는 프로세스의 Context switch와 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.
    <ul>
      <li>시스템의 처리율(throughput)이 향상되고 자원 소모가 줄어들며, 자연스럽게 프로그램의 응답 시간이 단축된다.</li>
    </ul>
  </li>
</ul>

<h5 id="2-2-멀티-스레딩의-문제점"><strong>2-2. 멀티 스레딩의 문제점</strong></h5>
<ul>
  <li>멀티 프로세스 기반으로 프로그래밍 할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 접근하는 일이 없었다.</li>
  <li>멀티 스레딩은 서로 다른 프로세스가 데이터 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용 중인 변수나 자료구조에 접근했을 때, 엉뚱한 값을 가져오거나 이로 인해 수정하는 일이 발생한다.
    <ul>
      <li>동기화 작업이 필요: 동기화를 통해 작업 처리 순서를 컨트롤하고, 공유 자원에 접근하는 것을 컨트롤 하는 것</li>
    </ul>
  </li>
  <li>동기화 작업으로 인하여 과도한 락이 발생할 수 있다.</li>
</ul>

<h5 id="2-3-멀티-스레드와-멀티-프로세스"><strong>2-3. 멀티 스레드와 멀티 프로세스</strong></h5>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: left">멀티 스레드</th>
      <th style="text-align: left">멀티 프로세스</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">장점</td>
      <td style="text-align: left">멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥전환이 빠르다.</td>
      <td style="text-align: left">하나의 프로세스가 죽어도 다른 프로세스에 영향이 없다.</td>
    </tr>
    <tr>
      <td style="text-align: center">단점</td>
      <td style="text-align: left">- 오류로 인해 하나의 스레드가 종료되면, 전체 스레드가 종료될 수 있다.<br />- 동기화 문제</td>
      <td style="text-align: left">멀티 스레드보다 많은 메모리 공간과 CPU 시간 차지</td>
    </tr>
  </tbody>
</table>

<h4 id="3-스케줄러"><strong>3. 스케줄러</strong></h4>
<h5 id="31-queue의-종류"><strong>3.1. Queue의 종류</strong></h5>
<p>: 프로세스를 스케줄링하기 위한 3가지 종류의 Queue</p>
<ul>
  <li>Job Queue: 현재 시스템 내에 있는 모든 프로세스의 집합</li>
  <li>Ready Queue: 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 집합</li>
  <li>Device Queue: Device I/O 작업을 대기하고 있는 프로세스의 집합</li>
</ul>

<h5 id="32-장기-스케줄러long-term-scheduler-or-job-scheduler"><strong>3.2. 장기 스케줄러(Long-term Scheduler or Job Scheduler)</strong></h5>
<p>(1) 메모리와 디스크 사이의 스케줄링 담당</p>
<ul>
  <li>메모리는 한정되어 있기 때문에 많은 프로세스가 한꺼번에 올라오는 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장된다. 이 pool에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 Ready Queue에 보낼 것인지 결정한다.</li>
</ul>

<p>(2) 프로세스에 memory 및 각종 resource 할당(admit) <br />
(3) 실행 중인 프로세스의 수(degree of multiprogramming) 제어 <br />
(4) 프로세스의 상태: new → ready(in memory)</p>

<h5 id="33-단기-스케줄러short-term-scheduler-or-cpu-scheduler"><strong>3.3. 단기 스케줄러(Short-term Scheduler or CPU Scheduler)</strong></h5>
<p>(1) CPU와 메모리 사이의 스케줄링을 담당 <br />
(2) Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬 것인지 결정 <br />
(3) 프로세스에 CPU를 할당(Scheduler dispatch) <br />
(4) 프로세스의 상태: ready → running → waiting → ready</p>

<h5 id="34-중기-스케줄러mid-term-scheduler-or-swapper"><strong>3.4. 중기 스케줄러(Mid-term Scheduler or Swapper)</strong></h5>
<p>(1) 여유공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄(Swapping) <br />
(2) 프로세스에게서 memory를 deallocate 한다. <br />
(3) 실행 중인 프로세스의 수(degree of multiprogramming) 제어 <br />
(4) 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러 <br />
(5) 프로세스의 상태: ready → suspend</p>

<blockquote>
  <p><em>※ suspend(stopped) 상태</em></p>
  <ul>
    <li>외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태</li>
    <li>프로세스 전부가 디스크로 swap out 된다.</li>
    <li>blocked 상태는 다른 I/O를 기다리는 상태이기 때문에 스스로 ready 상태로 돌아갈 수 있지만, suspend 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다.</li>
  </ul>
</blockquote>

<p>참고: <a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner">https://github.com/JaeYeopHan/Interview_Question_for_Beginner</a></p>

  </div>

  <a class="u-url" href="/CS-OS" hidden></a>
</article>

<script>
  $(document).ready(function() {
    $('.highlighter-rouge div.highlight').prepend('<i class="fas fa-code code-block"></i>');
  })
</script>

      </div>
    </main>
    <script src="/assets/js/jquery-3.6.0.min.js" />
  </body>

</html>
