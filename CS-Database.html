<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Dokongg Blog</title>

  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="stylesheet" href="/assets/css/syntax-one-dark.css">
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dokongg Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>
        <div class="trigger">
          <div>
            <div id="search" >
                <span id="searchform" method="post" action="/search/" class="">
    <div class="form-group">
        <input class="search-input" onkeyup="myFunc()" id="keyword" type="text" name="keyword" placeholder="Search..." />
    </div>
    <script src="/assets/js/jquery-3.6.0.min.js"></script>

    <script type="text/javascript">
        function myFunc() {
            var keyword = $("#keyword").val();

            if( keyword.trim() == '' ) {
              return;
            }
            if(event.keyCode == 13) {
                var url = encodeURIComponent(keyword);
                location.href = "/search?query=" + url;
            }
        }
    </script>
</span>

            </div>
          </div>
          
            <a class="page-link" href="/Algorithms/index">Algorithms</a>
          
            <a class="page-link" href="/CS/index">CS</a>
          
            <a class="page-link" href="/Java/index">Java</a>
          
            <a class="page-link" href="/Spring/index">Spring</a>
          
            <a class="page-link" href="/JPA/index">JPA</a>
          
            <a class="page-link" href="/ES/index">ES</a>
          
            <a class="page-link" href="/MSA/index">MSA</a>
          
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h3 class="post-title p-name" itemprop="name headline">Part 1-5. 데이터베이스</h3>
    <p class="post-meta post-right"><time class="dt-published" datetime="2021-05-12T00:00:00+00:00" itemprop="datePublished">
        2021-05-12
      </time></p>
  </header>

  <div class="post-content e-content post-content-body" itemprop="articleBody">
    <ol>
  <li>
    <p><strong>데이터베이스</strong> <br />
1.1. 데이터베이스를 사용하는 이유 <br />
1.2. 데이터베이스의 특징 <br />
1.3. 데이터베이스의 성능</p>
  </li>
  <li>
    <p><strong>Index</strong> <br />
2.1. Index란 무엇인가 <br />
2.2. Index의 자료구조 <br />
2.3. Primary index vs. Secondary index <br />
2.4. Composite index <br />
2.5. Index의 성능과 고려해야 할 사항</p>
  </li>
  <li>
    <p><strong>정규화</strong> <br />
3.1. 정규화의 탄생 배경<br />
3.2. 정규화란 무엇인가 <br />
3.3. 정규화의 종류</p>
  </li>
  <li>
    <p><strong>Transaction</strong> <br />
4.1. 트랜잭션(Transaction)이란 무엇인가<br />
4.2. 트랜잭션과 Lock   <br />
4.3. 트랜잭션의 특성<br />
4.4. 트랜잭션의 상태
4.5. 트랜잭션을 사용할 때 주의할 점</p>
  </li>
  <li>
    <p><strong>교착상태</strong> <br />
5.1. 교착상태란 무엇인가 <br />
5.2. 교착상태의 예시(Mysql) <br />
5.3. 교착상태의 빈도를 낮추는 방법</p>
  </li>
  <li>
    <p><strong>Statement vs. PreparedStatement</strong></p>
  </li>
  <li>
    <p><strong>NoSQL</strong> <br />
7.1. NoSQL의 정의 <br />
7.2. CAP 이론 <br />
7.2. 저장 방식에 따른 분류</p>
  </li>
</ol>

<hr />

<h4 id="1-데이터베이스"><strong>1. 데이터베이스</strong></h4>

<h5 id="11-데이터베이스를-사용하는-이유"><strong>1.1. 데이터베이스를 사용하는 이유</strong></h5>
<ul>
  <li>데이터베이스가 존재하기 이전
    <ul>
      <li>파일 시스템을 이용하여 데이터를 관리</li>
      <li>데이터를 각각의 파일 단위로 저장하며, 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동되어야 한다.
        <ul>
          <li>데이터의 종속성 문제와 중복성, 데이터의 무결성 문제 발생</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="12-데이터베이스의-특징"><strong>1.2. 데이터베이스의 특징</strong></h5>
<p>(1) 데이터의 독립성</p>
<ul>
  <li>물리적 독립성: 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.</li>
  <li>논리적 독립성: 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시킬 수 있다.</li>
</ul>

<p>(2) 데이터의 무결성</p>
<ul>
  <li>여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지</li>
  <li>데이터 유효성 검사를 통해 구현</li>
</ul>

<p>(3) 데이터의 보안성</p>
<ul>
  <li>인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정</li>
</ul>

<p>(4) 데이터의 일관성</p>
<ul>
  <li>연관된 정보를 논리적인 구조로 관리함으로써, 어떠 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다.</li>
  <li>작업 중 일부 데이터만 변경되기 때문에 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.</li>
</ul>

<p>(5) 데이터 중복의 최소화</p>
<ul>
  <li>데이터를 통합하여 관리함으로써, 파일 시스템의 단점 중에 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.</li>
</ul>

<h5 id="13-데이터베이스의-성능"><strong>1.3. 데이터베이스의 성능</strong></h5>
<ul>
  <li>디스크 I/O를 어떻게 줄이느냐에서 시작
    <ul>
      <li>디스크 I/O: 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터를 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것</li>
      <li>데이터를 읽는 데 걸리는 시간: 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.
        <ul>
          <li>디스크의 성능은 디스크 헤더의 위치 이동없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.</li>
        </ul>
      </li>
      <li>순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없다.
        <ul>
          <li>쿼리 튜닝: 현실에서는 대부분의 I/O이 랜덤 I/O이기 때문에, 랜덤 I/O를 순차 I/O로 바꿔서 실행할 수 없을까라는 생각에서 시작하여, 랜덤 I/O 자체를 줄여주는 것</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="2-index"><strong>2. Index</strong></h4>
<h5 id="21-index란-무엇인가"><strong>2.1. Index란 무엇인가</strong></h5>
<p>(1) 정의</p>
<ul>
  <li>책의 맨 처음 또는 맨 마지막에 있는 색인
    <ul>
      <li>데이터: 책의 내용</li>
      <li>데이터가 저장된 레코드의 주소: 인덱스 목록에 있는 페이지의 번호</li>
    </ul>
  </li>
  <li>컬럼의 값과 해당 레코드아 저장된 주소를 키와 값의 쌍으로 만들어두는 것
    <ul>
      <li>DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸리기 때문</li>
    </ul>
  </li>
</ul>

<p>(2) 특징</p>
<ul>
  <li>항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는 데에는 빠르지만, 새로운 값을 추가/삭제/수정하는 경우에는 쿼리문 실행 속도가 느려진다.
    <ul>
      <li>인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SELECT</code> 쿼리문의 <code class="language-plaintext highlighter-rouge">WHERE</code> 조건절에 사용되는 컬럼이라고 전부 인덱스로 생성하면, 데이터의 저장능력이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과 발생</li>
</ul>

<h5 id="22-index의-자료구조"><strong>2.2. Index의 자료구조</strong></h5>
<p>(1) B+-Tree 인덱스 알고리즘</p>
<ul>
  <li>일반적으로 사용되는 인덱스 알고리즘</li>
  <li>컬럼의 값을 변형하지 않고(실제로는 값의 앞 부분만 잘라서 관리한다 원래의 값을 이용해 인덱싱하는 방법</li>
</ul>

<p>(2) Hash 인덱스 알고리즘</p>
<ul>
  <li>컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘</li>
  <li>값을 변형해서 인덱싱 하므로, 특정 문자로 시작하는 값으로 검색하는 전방 일치과 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다.</li>
  <li>주로 메모리 기반의 데이터베이스에서 많이 사용</li>
</ul>

<p>(3) index 생성 시 B+-Tree 인덱스 알고리즘을 사용하는 이유</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">SELECT</code> 쿼리문의 조건에는 부등호(&lt;&gt;) 연산도 포함이 된다. Hash 인덱스 알고리즘의 경우, hash table을 사용하게 된다면, 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다.
    <ul>
      <li>동등 연산(=)에 특화된 <code class="language-plaintext highlighter-rouge">hashtable</code>은 데이터베이스의 자료구조로 적합하지 않다.</li>
    </ul>
  </li>
</ul>

<h5 id="23-primary-index-vs-secondary-index"><strong>2.3. Primary index vs. Secondary index</strong></h5>
<h5 id="24-composite-index"><strong>2.4. Composite index</strong></h5>
<h5 id="25-index의-성능과-고려해야-할-사항"><strong>2.5. Index의 성능과 고려해야 할 사항</strong></h5>

<h4 id="3-정규화"><strong>3. 정규화</strong></h4>
<h5 id="31-정규화의-탄생-배경"><strong>3.1. 정규화의 탄생 배경</strong></h5>
<h5 id="32-정규화란-무엇인가"><strong>3.2. 정규화란 무엇인가</strong></h5>
<h5 id="33-정규화의-종류"><strong>3.3. 정규화의 종류</strong></h5>

<h4 id="4-transaction"><strong>4. Transaction</strong></h4>

<h5 id="41-트랜잭션transaction이란-무엇인가"><strong>4.1. 트랜잭션(Transaction)이란 무엇인가</strong></h5>
<ul>
  <li>작업의 완전성을 보장해주는 것
    <ul>
      <li>논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않도록 함</li>
    </ul>
  </li>
  <li>사용자의 입장에서는 논리적 단위로, 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위</li>
</ul>

<h5 id="42-트랜잭션과-lock"><strong>4.2. 트랜잭션과 Lock</strong></h5>
<p>(1) 트랜잭션</p>
<ul>
  <li>데이터의 정합성을 보장하기 위한 기능</li>
  <li>반드시 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아님
    <ul>
      <li>하나의 논리적인 작업 셋 중 쿼리의 개수와는 상관없이 논리적인 작업 셋 자체가 100% 적용되거나 아무 것도 적용되지 않아야 함을 보장하는 것</li>
    </ul>
  </li>
</ul>

<p>(2) Lock</p>
<ul>
  <li>동시성을 제어하기 위한 기능</li>
  <li>여러 커넥션에서 동시에 동일한 자원을 요청할 경우, 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 하는 역할
    <ul>
      <li>자원: 레코드나 테이블</li>
    </ul>
  </li>
</ul>

<h5 id="43-트랜잭션의-특성-acid"><strong>4.3. 트랜잭션의 특성: ACID</strong></h5>

<p>(1) Atomicity: 원자성</p>
<ul>
  <li>트랜잭션 중간에 어떠한 문제가 발생한다면, 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안된다.
    <ul>
      <li>아무런 문제가 발생하지 않았을 경우에만 수행되어야 한다.</li>
    </ul>
  </li>
</ul>

<p>(2) Consistency: 일관성</p>
<ul>
  <li>트랜잭션이 완료된 다음의 상태에서도 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.</li>
</ul>

<p>(3) Isolation: 고립성</p>
<ul>
  <li>각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.</li>
</ul>

<p>(4) Durability: 지속성</p>
<ul>
  <li>트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.</li>
</ul>

<h5 id="44-트랜잭션의-상태"><strong>4.4. 트랜잭션의 상태</strong></h5>
<p><img src="https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/Database/images/transaction-status.png?raw=true" alt="Alt Text" /></p>

<p>(1) Active: 트랜잭션 활동 상태</p>
<ul>
  <li>트랜잭션이 실행 중이며, 동작 중인 상태</li>
</ul>

<p>(2) Failed: 트랜잭션 실패 상태</p>
<ul>
  <li>트랜잭션을 더 이상 정상적으로 진행할 수 없는 상태</li>
</ul>

<p>(3) Partially Committed: 트랜잭션의 <code class="language-plaintext highlighter-rouge">Commit</code> 명령이 도착한 상태</p>
<ul>
  <li>트랜잭션의 <code class="language-plaintext highlighter-rouge">Commit</code> 이전의 <code class="language-plaintext highlighter-rouge">sql</code>문이 수행되고, <code class="language-plaintext highlighter-rouge">Commit</code>만 남은 상태</li>
</ul>

<p>(4) Commited: 트랜잭션 완료 상태</p>
<ul>
  <li>트랜잭션이 정상적으로 완료된 상태</li>
</ul>

<p>(5) Aborted: 트랜잭션 취소 상태</p>
<ul>
  <li>트랜잭션이 취소되고 트랜잭션 실행 이전의 데이터로 돌아간 상태</li>
</ul>

<blockquote>
  <p><em><strong>※ Partially Commited와 Commited의 차이점</strong></em></p>
  <ol>
    <li><code class="language-plaintext highlighter-rouge">Partially Committed</code>
      <ul>
        <li><code class="language-plaintext highlighter-rouge">Commit</code> 요청이 들어왔을 때</li>
        <li>이 후, <code class="language-plaintext highlighter-rouge">Commit</code>을 문제없이 수행할 수 있으면 <code class="language-plaintext highlighter-rouge">Commited</code> 상태, 만약 오류가 발생하면 <code class="language-plaintext highlighter-rouge">Failed</code> 상태가 된다.</li>
      </ul>
    </li>
    <li><code class="language-plaintext highlighter-rouge">Commited</code>
      <ul>
        <li><code class="language-plaintext highlighter-rouge">Commit</code>을 정상적으로 완료한 상태</li>
      </ul>
    </li>
  </ol>
</blockquote>

<h5 id="45-트랜잭션을-사용할-때-주의할-점"><strong>4.5. 트랜잭션을 사용할 때 주의할 점</strong></h5>
<ul>
  <li>트랜잭션의 범위를 최소화하여 적용한다.
    <ul>
      <li>반드시 필요한 최소의 코드에만 적용하는 것이 좋다.
        <ul>
          <li>일반적으로 데이터베이스 커넥션 개수는 제한적인데, 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 그 사용 가능한 여유 개수는 줄어들게 된다.</li>
          <li>어느 순간 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 도 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="5-교착상태"><strong>5. 교착상태</strong></h4>
<h5 id="51-교착상태란-무엇인가"><strong>5.1. 교착상태란 무엇인가</strong></h5>
<h5 id="52-교착상태의-예시mysql"><strong>5.2. 교착상태의 예시(Mysql)</strong></h5>
<h5 id="53-교착상태의-빈도를-낮추는-방법"><strong>5.3. 교착상태의 빈도를 낮추는 방법</strong></h5>

<h4 id="6-statement-vs-preparedstatement"><strong>6. Statement vs. PreparedStatement</strong></h4>

<h4 id="7-nosql"><strong>7. NoSQL</strong></h4>
<h5 id="71-nosql의-정의"><strong>7.1. NoSQL의 정의</strong></h5>
<h5 id="72-cap-이론"><strong>7.2. CAP 이론</strong></h5>
<h5 id="72-저장-방식에-따른-분류"><strong>7.2. 저장 방식에 따른 분류</strong></h5>

<p>참고: <a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner">https://github.com/JaeYeopHan/Interview_Question_for_Beginner</a></p>

  </div>

  <a class="u-url" href="/CS-Database" hidden></a>
</article>

<script>
  $(document).ready(function() {
    $('.highlighter-rouge div.highlight').prepend('<i class="fas fa-code code-block"></i>');
  })
</script>

      </div>
    </main>
    <script src="/assets/js/jquery-3.6.0.min.js" />
  </body>

</html>
